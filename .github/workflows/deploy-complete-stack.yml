name: ðŸš€ Deploy Complete MLOps Stack to EKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      api_image_tag:
        description: 'FastAPI Docker image tag'
        required: false
        default: 'latest'
      ui_image_tag:
        description: 'UI Docker image tag'
        required: false
        default: 'latest'
      skip_api:
        description: 'Skip FastAPI deployment'
        required: false
        default: false
        type: boolean
      skip_ui:
        description: 'Skip UI deployment'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY_API: churn-prediction-api
  ECR_REPOSITORY_UI: churn-prediction-ui
  EKS_CLUSTER_NAME: churnmodel

jobs:
  deploy-complete-stack:
    name: ðŸš€ Deploy Complete MLOps Stack
    runs-on: ubuntu-latest
    
    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4
      
    - name: ðŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: ðŸ“¦ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: âš™ï¸ Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        kubectl version --client
        echo "âœ… kubectl configured for EKS cluster: ${{ env.EKS_CLUSTER_NAME }}"
        
    - name: ðŸ” Create ECR Repositories
      run: |
        # Create API repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_API }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY_API }}
        
        # Create UI repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_UI }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY_UI }}
        
        echo "âœ… ECR repositories verified/created"
        
    # FastAPI Deployment
    - name: ðŸ”§ Deploy FastAPI Backend
      if: ${{ !github.event.inputs.skip_api }}
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.event.inputs.api_image_tag || 'latest' }}
      run: |
        echo "ðŸ”§ Starting FastAPI deployment..."
        
        # Build FastAPI image
        cd fastapi-deployment/
        echo "ðŸ”¨ Building FastAPI Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ github.sha }} \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_API:latest .
        
        # Test API image
        echo "ðŸ§ª Testing FastAPI image..."
        docker run --rm -d --name test-api -p 8000:8000 \
          $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
        sleep 15
        
        if curl -f http://localhost:8000/health; then
          echo "âœ… FastAPI health check passed"
        else
          echo "âŒ FastAPI health check failed"
          docker logs test-api
          exit 1
        fi
        docker stop test-api
        
        # Push API image
        echo "ðŸ“¤ Pushing FastAPI images..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:${{ github.sha }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:latest
        
        # Create AWS credentials secret
        kubectl delete secret aws-credentials --ignore-not-found=true
        kubectl create secret generic aws-credentials \
          --from-literal=aws-access-key-id=${{ secrets.AWS_ACCESS_KEY_ID }} \
          --from-literal=aws-secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        
        # Update Kubernetes manifests
        sed -i "s|image: churn-prediction-api:latest|image: $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG|g" k8s-deployment.yaml
        
        # Deploy to EKS
        echo "ðŸš€ Deploying FastAPI to EKS..."
        kubectl apply -f k8s-deployment.yaml
        kubectl rollout status deployment/churn-prediction-api --timeout=300s
        
        echo "âœ… FastAPI deployment completed!"
        
    - name: ðŸ” Get FastAPI URL
      id: get-api-url
      run: |
        # Wait for API service to be ready
        sleep 10
        
        NODE_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
        
        if [ -n "$NODE_IP" ]; then
          API_URL="http://$NODE_IP:$NODE_PORT"
        else
          API_URL="http://NODE_IP:30080"
        fi
        
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "ðŸ”— FastAPI URL: $API_URL"
        
    # UI Deployment
    - name: ðŸŽ¨ Deploy UI Frontend
      if: ${{ !github.event.inputs.skip_ui }}
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.event.inputs.ui_image_tag || 'latest' }}
        API_URL: ${{ steps.get-api-url.outputs.api_url }}
      run: |
        echo "ðŸŽ¨ Starting UI deployment..."
        
        # Update API configuration in UI
        cd ui-deployment/
        echo "ðŸ”§ Updating API URL to: $API_URL"
        sed -i "s|http://NODE_IP:30080|$API_URL|g" script.js
        
        # Build UI image
        echo "ðŸ”¨ Building UI Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_UI:${{ github.sha }} \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY_UI:latest .
        
        # Test UI image
        echo "ðŸ§ª Testing UI image..."
        docker run --rm -d --name test-ui -p 3000:80 \
          $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG
        sleep 10
        
        if curl -f http://localhost:3000/health; then
          echo "âœ… UI health check passed"
        else
          echo "âŒ UI health check failed"
          docker logs test-ui
          exit 1
        fi
        
        if curl -f http://localhost:3000/ | grep -q "Customer Churn"; then
          echo "âœ… UI main page loads correctly"
        else
          echo "âŒ UI main page test failed"
          docker logs test-ui
          exit 1
        fi
        docker stop test-ui
        
        # Push UI image
        echo "ðŸ“¤ Pushing UI images..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_UI:${{ github.sha }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_UI:latest
        
        # Update Kubernetes manifests
        sed -i "s|image: churn-prediction-ui:latest|image: $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG|g" k8s-deployment.yaml
        
        # Deploy to EKS
        echo "ðŸš€ Deploying UI to EKS..."
        kubectl apply -f k8s-deployment.yaml
        kubectl rollout status deployment/churn-prediction-ui --timeout=300s
        
        echo "âœ… UI deployment completed!"
        
    - name: ðŸ” Verify Complete Deployment
      run: |
        echo "ðŸ” Verifying complete stack deployment..."
        
        # Check all pods
        echo "ðŸ“¦ Checking pods..."
        kubectl get pods -l tier=backend
        kubectl get pods -l tier=frontend
        
        # Check all services
        echo "ðŸŒ Checking services..."
        kubectl get services -l app=churn-prediction-api
        kubectl get services -l app=churn-prediction-ui
        
        # Get URLs
        API_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        UI_PORT=$(kubectl get service churn-prediction-ui-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30081")
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || echo "NODE_IP")
        
        echo "ðŸ”— Service URLs:"
        echo "  FastAPI: http://$NODE_IP:$API_PORT"
        echo "  UI: http://$NODE_IP:$UI_PORT"
        echo "  API Docs: http://$NODE_IP:$API_PORT/docs"
        
    - name: ðŸ§ª End-to-End Health Check
      run: |
        echo "ðŸ§ª Running end-to-end health checks..."
        
        # Wait for services to be fully ready
        sleep 30
        
        API_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        UI_PORT=$(kubectl get service churn-prediction-ui-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30081")
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
        
        if [ -n "$NODE_IP" ]; then
          echo "ðŸ” Testing FastAPI health..."
          if curl -f "http://$NODE_IP:$API_PORT/health"; then
            echo "âœ… FastAPI health check passed"
          else
            echo "âš ï¸ FastAPI health check failed"
          fi
          
          echo "ðŸ” Testing UI health..."
          if curl -f "http://$NODE_IP:$UI_PORT/health"; then
            echo "âœ… UI health check passed"
          else
            echo "âš ï¸ UI health check failed"
          fi
          
          echo "ðŸ” Testing API-UI connectivity..."
          if curl -f "http://$NODE_IP:$API_PORT/model-info"; then
            echo "âœ… API model endpoint accessible"
          else
            echo "âš ï¸ API model endpoint not accessible"
          fi
        else
          echo "âš ï¸ External IP not available, using port-forward for testing..."
          kubectl port-forward service/churn-prediction-api-service 8000:80 &
          kubectl port-forward service/churn-prediction-ui-service 3000:80 &
          sleep 5
          
          curl -f http://localhost:8000/health && echo "âœ… API accessible via port-forward"
          curl -f http://localhost:3000/health && echo "âœ… UI accessible via port-forward"
          
          pkill -f "kubectl port-forward" || true
        fi
        
    - name: ðŸ“Š Complete Stack Summary
      run: |
        API_PORT=$(kubectl get service churn-prediction-api-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
        UI_PORT=$(kubectl get service churn-prediction-ui-nodeport -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30081")
        
        echo "## ðŸŽ‰ Complete MLOps Stack Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | Port |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|------|" >> $GITHUB_STEP_SUMMARY
        echo "| FastAPI Backend | âœ… Deployed | $API_PORT |" >> $GITHUB_STEP_SUMMARY
        echo "| UI Frontend | âœ… Deployed | $UI_PORT |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Images | âœ… Pushed to ECR | - |" >> $GITHUB_STEP_SUMMARY
        echo "| Health Checks | âœ… Passed | - |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ðŸ”— Access Your MLOps Stack" >> $GITHUB_STEP_SUMMARY
        echo "1. **Get Node IP**: \`kubectl get nodes -o wide\`" >> $GITHUB_STEP_SUMMARY
        echo "2. **UI Interface**: \`http://NODE_IP:$UI_PORT\`" >> $GITHUB_STEP_SUMMARY
        echo "3. **API Health**: \`http://NODE_IP:$API_PORT/health\`" >> $GITHUB_STEP_SUMMARY
        echo "4. **API Documentation**: \`http://NODE_IP:$API_PORT/docs\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ðŸŽ¯ What You Can Do Now" >> $GITHUB_STEP_SUMMARY
        echo "- **ðŸ”® Make Predictions**: Use the UI to predict customer churn" >> $GITHUB_STEP_SUMMARY
        echo "- **ðŸ“Š Monitor Models**: Check model status in the UI" >> $GITHUB_STEP_SUMMARY
        echo "- **ðŸ§ª Test API**: Use the Swagger docs for API testing" >> $GITHUB_STEP_SUMMARY
        echo "- **ðŸ“ˆ Track Experiments**: View MLflow at http://3.110.135.31:30418/" >> $GITHUB_STEP_SUMMARY
        echo "- **ðŸ”„ Approve Models**: Manage models in SageMaker Registry" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ðŸ› ï¸ Troubleshooting" >> $GITHUB_STEP_SUMMARY
        echo "- **Check pods**: \`kubectl get pods\`" >> $GITHUB_STEP_SUMMARY
        echo "- **View logs**: \`kubectl logs -l app=churn-prediction-api\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Port forward**: \`kubectl port-forward svc/churn-prediction-ui-service 3000:80\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Model reload**: Use UI \"Reload Model\" button" >> $GITHUB_STEP_SUMMARY 